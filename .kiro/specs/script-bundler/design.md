# Design Document: Script Bundler

## Overview

Script-bundler is a REST API service that converts shell scripts generated by packmate into native executables. The service accepts PowerShell scripts (for Windows) or Bash scripts (for macOS/Linux) and produces downloadable executables (.exe for Windows, .app bundles for macOS).

The architecture follows a job-based async pattern where script submission returns a job ID, and clients poll for completion before downloading. This allows for potentially long-running bundling operations without blocking HTTP connections.

### Key Design Decisions

1. **Node.js/Express backend**: Aligns with packmate's tech stack, enabling code sharing and consistent tooling
2. **Docker-based deployment**: Required for bundling tools (PS2EXE requires PowerShell, Platypus requires macOS tools)
3. **In-memory job queue**: Simple approach suitable for render.com's single-instance deployment
4. **File-based temporary storage**: Generated executables stored on disk with TTL-based cleanup

## Architecture

```mermaid
flowchart TB
    subgraph Client
        PM[Packmate Frontend]
    end
    
    subgraph Script Bundler Service
        API[Express API Layer]
        VAL[Script Validator]
        JQ[Job Queue]
        BE[Bundling Engine]
        FS[File Store]
        CL[Cleanup Scheduler]
    end
    
    subgraph Bundling Tools
        PS2[PS2EXE - Windows]
        PLT[Platypus CLI - macOS]
    end
    
    PM -->|POST /api/bundle| API
    PM -->|GET /api/status/:jobId| API
    PM -->|GET /api/download/:jobId| API
    
    API --> VAL
    VAL --> JQ
    JQ --> BE
    BE --> PS2
    BE --> PLT
    BE --> FS
    CL --> FS
```

### Request Flow

```mermaid
sequenceDiagram
    participant C as Client
    participant A as API
    participant V as Validator
    participant Q as Job Queue
    participant B as Bundler
    participant S as File Store
    
    C->>A: POST /api/bundle
    A->>V: Validate script
    V-->>A: Validation result
    alt Invalid
        A-->>C: 400 Error
    else Valid
        A->>Q: Create job
        Q-->>A: Job ID
        A-->>C: 202 Accepted + Job ID
    end
    
    Q->>B: Process job
    B->>S: Store executable
    B->>Q: Update status
    
    C->>A: GET /api/status/:jobId
    A->>Q: Get job status
    Q-->>A: Status + download URL
    A-->>C: Job status
    
    C->>A: GET /api/download/:jobId
    A->>S: Get file
    S-->>A: File stream
    A-->>C: Executable file
```

## Components and Interfaces

### 1. API Layer (Express Router)

Handles HTTP requests and responses, enforces rate limiting, and manages CORS.

```typescript
// src/api/routes.ts

interface BundleRequest {
  script: string;           // Script content
  platform: 'windows' | 'macos';
  metadata?: {
    name?: string;          // Custom executable name
    version?: string;       // Version string
  };
}

interface BundleResponse {
  jobId: string;
  status: 'queued';
  statusUrl: string;
}

interface StatusResponse {
  jobId: string;
  status: 'queued' | 'processing' | 'completed' | 'failed';
  downloadUrl?: string;     // Present when completed
  error?: string;           // Present when failed
  createdAt: string;
  updatedAt: string;
}

// Endpoints
// POST /api/bundle - Submit script for bundling
// GET /api/status/:jobId - Check job status
// GET /api/download/:jobId - Download executable
// GET /health - Health check
```

### 2. Script Validator

Validates and sanitizes scripts before bundling. Implements security checks to prevent malicious code execution.

```typescript
// src/validation/validator.ts

interface ValidationResult {
  valid: boolean;
  errors: string[];
  sanitizedScript?: string;
}

interface ValidatorConfig {
  maxScriptSize: number;           // Max script size in bytes
  prohibitedPatterns: RegExp[];    // Patterns to reject
  requiredPatterns: RegExp[];      // Patterns that must be present (packmate format)
}

class ScriptValidator {
  constructor(config: ValidatorConfig);
  
  // Validate script content and platform
  validate(script: string, platform: 'windows' | 'macos'): ValidationResult;
  
  // Check for prohibited commands
  private checkProhibitedPatterns(script: string): string[];
  
  // Verify packmate format
  private verifyPackmateFormat(script: string, platform: string): boolean;
  
  // Sanitize script (escape dangerous patterns)
  private sanitize(script: string): string;
}
```

#### Prohibited Patterns

**PowerShell (Windows)**:
- `Invoke-WebRequest`, `Invoke-RestMethod`, `wget`, `curl` (arbitrary downloads)
- `Start-Process` with external URLs
- `[System.Net.WebClient]` usage
- Base64 encoded commands (`-EncodedCommand`)
- `Remove-Item -Recurse` on system paths
- Registry modifications outside expected scope

**Bash (macOS)**:
- `curl`, `wget` downloading executables
- `eval` with external input
- `rm -rf /` or similar destructive patterns
- Base64 decoding and execution
- `/etc/passwd`, `/etc/shadow` access
- `chmod 777` on system directories

### 3. Job Queue

In-memory job queue with status tracking. Jobs have a TTL and are cleaned up automatically.

```typescript
// src/queue/jobQueue.ts

type JobStatus = 'queued' | 'processing' | 'completed' | 'failed';

interface Job {
  id: string;
  status: JobStatus;
  platform: 'windows' | 'macos';
  script: string;
  metadata?: { name?: string; version?: string };
  outputPath?: string;      // Path to generated executable
  error?: string;
  createdAt: Date;
  updatedAt: Date;
  expiresAt: Date;
}

class JobQueue {
  private jobs: Map<string, Job>;
  private processingQueue: string[];
  
  // Create a new job
  createJob(script: string, platform: string, metadata?: object): Job;
  
  // Get job by ID
  getJob(jobId: string): Job | undefined;
  
  // Update job status
  updateJob(jobId: string, updates: Partial<Job>): void;
  
  // Get next job to process
  getNextJob(): Job | undefined;
  
  // Remove expired jobs
  cleanupExpired(): void;
}
```

### 4. Bundling Engine

Orchestrates the bundling process using platform-specific tools.

```typescript
// src/bundler/engine.ts

interface BundleResult {
  success: boolean;
  outputPath?: string;
  error?: string;
}

class BundlingEngine {
  constructor(
    private tempDir: string,
    private windowsBundler: WindowsBundler,
    private macosBundler: MacOSBundler
  );
  
  // Bundle script for target platform
  async bundle(job: Job): Promise<BundleResult>;
  
  // Clean up temporary files for a job
  async cleanup(jobId: string): Promise<void>;
}
```

### 5. Windows Bundler (PS2EXE)

Converts PowerShell scripts to .exe files using PS2EXE.

```typescript
// src/bundler/windows.ts

interface WindowsBundlerConfig {
  ps2exePath: string;       // Path to PS2EXE module
  tempDir: string;
  defaultIcon?: string;     // Default icon for executables
}

class WindowsBundler {
  constructor(config: WindowsBundlerConfig);
  
  // Convert PowerShell script to .exe
  async bundle(
    script: string,
    outputName: string,
    options?: { requireAdmin?: boolean }
  ): Promise<BundleResult>;
}
```

**PS2EXE Command**:
```powershell
Invoke-PS2EXE -InputFile "script.ps1" -OutputFile "output.exe" -NoConsole -RequireAdmin
```

### 6. macOS Bundler (Platypus)

Creates .app bundles from Bash scripts using Platypus CLI.

```typescript
// src/bundler/macos.ts

interface MacOSBundlerConfig {
  platypusPath: string;     // Path to platypus CLI
  tempDir: string;
  defaultIcon?: string;     // Default icon for apps
}

class MacOSBundler {
  constructor(config: MacOSBundlerConfig);
  
  // Convert Bash script to .app bundle
  async bundle(
    script: string,
    outputName: string,
    options?: { runInTerminal?: boolean }
  ): Promise<BundleResult>;
  
  // Zip the .app bundle for download
  private async zipBundle(appPath: string): Promise<string>;
}
```

**Platypus Command**:
```bash
platypus -a "AppName" -o "Text Window" -i icon.icns -V "1.0" script.sh output.app
```

### 7. File Store

Manages temporary storage of generated executables.

```typescript
// src/storage/fileStore.ts

interface FileStoreConfig {
  basePath: string;         // Base directory for storage
  maxAge: number;           // Max file age in milliseconds
}

class FileStore {
  constructor(config: FileStoreConfig);
  
  // Store a file and return its path
  store(jobId: string, filePath: string): Promise<string>;
  
  // Get file path for a job
  getPath(jobId: string): string | undefined;
  
  // Delete file for a job
  delete(jobId: string): Promise<void>;
  
  // Delete all expired files
  cleanupExpired(): Promise<number>;
  
  // Get file stream for download
  getStream(jobId: string): fs.ReadStream | undefined;
}
```

### 8. Cleanup Scheduler

Periodically cleans up expired jobs and files.

```typescript
// src/scheduler/cleanup.ts

interface CleanupConfig {
  interval: number;         // Cleanup interval in milliseconds
  jobTTL: number;           // Job time-to-live in milliseconds
  fileTTL: number;          // File time-to-live in milliseconds
}

class CleanupScheduler {
  constructor(
    config: CleanupConfig,
    jobQueue: JobQueue,
    fileStore: FileStore
  );
  
  // Start the cleanup scheduler
  start(): void;
  
  // Stop the cleanup scheduler
  stop(): void;
  
  // Run cleanup immediately
  runNow(): Promise<{ jobsCleaned: number; filesCleaned: number }>;
}
```

## Data Models

### Job Model

```typescript
interface Job {
  id: string;                           // UUID v4
  status: 'queued' | 'processing' | 'completed' | 'failed';
  platform: 'windows' | 'macos';
  script: string;                       // Original script content
  sanitizedScript: string;              // Validated/sanitized script
  metadata: {
    name: string;                       // Executable name
    version: string;                    // Version string
  };
  outputPath: string | null;            // Path to generated file
  outputSize: number | null;            // File size in bytes
  error: string | null;                 // Error message if failed
  clientIp: string;                     // For rate limiting
  createdAt: Date;
  updatedAt: Date;
  expiresAt: Date;                      // When job/file expires
  downloadedAt: Date | null;            // When file was downloaded
}
```

### Configuration Model

```typescript
interface AppConfig {
  port: number;                         // Server port (default: 3000)
  host: string;                         // Server host (default: 0.0.0.0)
  
  // Rate limiting
  rateLimit: {
    windowMs: number;                   // Time window (default: 15 min)
    maxRequests: number;                // Max requests per window (default: 10)
  };
  
  // Script validation
  validation: {
    maxScriptSize: number;              // Max size in bytes (default: 1MB)
  };
  
  // File storage
  storage: {
    basePath: string;                   // Temp directory path
    fileTTL: number;                    // File TTL in ms (default: 1 hour)
  };
  
  // Job queue
  queue: {
    jobTTL: number;                     // Job TTL in ms (default: 1 hour)
    cleanupInterval: number;            // Cleanup interval (default: 5 min)
  };
  
  // CORS
  cors: {
    allowedOrigins: string[];           // Allowed origins for CORS
  };
  
  // Bundler paths
  bundlers: {
    ps2exePath: string;                 // PS2EXE module path
    platypusPath: string;               // Platypus CLI path
  };
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Valid Submission Returns Job ID

*For any* valid script content and supported platform combination, submitting to the bundle endpoint SHALL return a response containing a non-empty job identifier string.

**Validates: Requirements 1.1, 6.1**

### Property 2: Invalid Platform Rejection

*For any* platform string that is not in the set {'windows', 'macos'}, submitting to the bundle endpoint SHALL return a 400 status code with an error message listing supported platforms.

**Validates: Requirements 1.3**

### Property 3: Script Size Limit Enforcement

*For any* script content exceeding the configured maximum size limit, submitting to the bundle endpoint SHALL return a 413 status code.

**Validates: Requirements 1.6**

### Property 4: Prohibited Pattern Rejection

*For any* script containing prohibited patterns (network download commands, dangerous file operations, encoded/obfuscated content), the validator SHALL reject the script with a 400 status code and specific error message identifying the violation.

**Validates: Requirements 2.1, 2.2, 2.3, 2.4, 2.5**

### Property 5: Valid Script Sanitization

*For any* script that passes validation, the validator SHALL return a sanitized version that is non-empty and preserves the functional intent of the original script.

**Validates: Requirements 2.6**

### Property 6: Packmate Format Validation

*For any* script generated by packmate's script generators, the validator SHALL accept it as valid. *For any* script not matching packmate's expected format markers, the validator SHALL reject it.

**Validates: Requirements 2.7, 9.1**

### Property 7: Platform-Appropriate Executable Generation

*For any* validated PowerShell script with Windows target, the bundler SHALL produce a file with .exe extension. *For any* validated Bash script with macOS target, the bundler SHALL produce a .app bundle.

**Validates: Requirements 3.1, 4.1**

### Property 8: macOS Bundle Structure

*For any* generated macOS .app bundle, the bundle SHALL contain the original script file and a valid Info.plist file with required metadata keys (CFBundleName, CFBundleIdentifier, CFBundleVersion).

**Validates: Requirements 4.2, 4.4**

### Property 9: Download Response Headers

*For any* successful download request, the response SHALL include Content-Type header matching the file type and Content-Disposition header with the filename.

**Validates: Requirements 5.2**

### Property 10: Non-Existent Job Returns 404

*For any* job ID that does not exist in the system, both the status endpoint and download endpoint SHALL return a 404 status code.

**Validates: Requirements 5.3, 6.5**

### Property 11: macOS Downloads Are Zipped

*For any* download request for a macOS executable, the response SHALL be a ZIP archive containing the .app bundle, with Content-Type of application/zip.

**Validates: Requirements 5.5**

### Property 12: Status Response State Consistency

*For any* job status request, the response SHALL contain a status field with value in {'queued', 'processing', 'completed', 'failed'}. When status is 'completed', downloadUrl SHALL be present. When status is 'failed', error SHALL be present.

**Validates: Requirements 6.2, 6.3, 6.4**

### Property 13: File Cleanup After Timeout

*For any* generated executable that has not been downloaded, after the configured TTL has elapsed, the file SHALL be deleted from storage.

**Validates: Requirements 7.1**

### Property 14: File Cleanup After Download

*For any* successful download, the corresponding file SHALL be deleted from storage immediately after the download completes.

**Validates: Requirements 7.2**

### Property 15: Rate Limiting Enforcement

*For any* IP address that exceeds the configured request limit within the time window, subsequent requests SHALL return 429 status code with Retry-After header.

**Validates: Requirements 8.1, 8.2**

### Property 16: Security Headers Present

*For any* response from the API, the response SHALL include security headers (X-Content-Type-Options, X-Frame-Options, Content-Security-Policy).

**Validates: Requirements 8.4**

### Property 17: CORS Headers Present

*For any* request from an allowed origin, the response SHALL include Access-Control-Allow-Origin header matching the request origin.

**Validates: Requirements 9.2**

### Property 18: Metadata Affects Output Filename

*For any* bundle request with metadata.name specified, the generated executable filename SHALL incorporate the provided name.

**Validates: Requirements 9.4**

### Property 19: Environment Variable Configuration

*For any* supported configuration option, setting the corresponding environment variable SHALL override the default value in the running application.

**Validates: Requirements 10.2**

## Error Handling

### API Error Responses

All error responses follow a consistent format:

```typescript
interface ErrorResponse {
  error: {
    code: string;           // Machine-readable error code
    message: string;        // Human-readable message
    details?: object;       // Additional context
  };
}
```

### Error Codes

| Code | HTTP Status | Description |
|------|-------------|-------------|
| `INVALID_REQUEST` | 400 | Missing or malformed request body |
| `INVALID_PLATFORM` | 400 | Unsupported target platform |
| `SCRIPT_EMPTY` | 400 | Script content is empty |
| `SCRIPT_INVALID` | 400 | Script failed validation |
| `SCRIPT_PROHIBITED` | 400 | Script contains prohibited patterns |
| `SCRIPT_FORMAT` | 400 | Script doesn't match packmate format |
| `SCRIPT_TOO_LARGE` | 413 | Script exceeds size limit |
| `JOB_NOT_FOUND` | 404 | Job ID doesn't exist |
| `JOB_EXPIRED` | 410 | Job/file has expired |
| `RATE_LIMITED` | 429 | Too many requests |
| `BUNDLING_FAILED` | 500 | Executable generation failed |
| `INTERNAL_ERROR` | 500 | Unexpected server error |

### Validation Error Details

When validation fails, the error response includes specific details:

```typescript
interface ValidationErrorDetails {
  violations: Array<{
    pattern: string;        // The prohibited pattern found
    line?: number;          // Line number if applicable
    description: string;    // Why this is prohibited
  }>;
}
```

### Graceful Degradation

- If bundling tools are unavailable, return 503 Service Unavailable
- If disk space is low, reject new jobs with 507 Insufficient Storage
- If cleanup fails, log error but don't affect user requests

## Testing Strategy

### Unit Tests

Unit tests verify individual components in isolation:

1. **Script Validator Tests**
   - Test each prohibited pattern is detected
   - Test valid packmate scripts pass validation
   - Test sanitization preserves script functionality
   - Test size limit enforcement

2. **Job Queue Tests**
   - Test job creation returns valid ID
   - Test job status transitions
   - Test job expiration
   - Test concurrent access

3. **File Store Tests**
   - Test file storage and retrieval
   - Test cleanup removes expired files
   - Test cleanup after download

4. **API Route Tests**
   - Test request validation
   - Test response format
   - Test error handling
   - Test CORS headers

### Property-Based Tests

Property-based tests use fast-check to verify universal properties:

- **Library**: fast-check
- **Minimum iterations**: 100 per property
- **Tag format**: `Feature: script-bundler, Property N: {property_text}`

Each correctness property from the design document will be implemented as a property-based test that generates random valid inputs and verifies the property holds.

### Integration Tests

Integration tests verify end-to-end flows:

1. **Happy Path**: Submit script → Check status → Download executable
2. **Validation Rejection**: Submit invalid script → Verify rejection
3. **Rate Limiting**: Exceed rate limit → Verify 429 response
4. **Cleanup**: Submit job → Wait for TTL → Verify cleanup

### Test Environment

- Use mock bundling tools for unit tests (avoid actual PS2EXE/Platypus)
- Use temporary directories for file storage tests
- Use in-memory job queue for isolation
- Integration tests may use real bundling tools in CI with Docker

